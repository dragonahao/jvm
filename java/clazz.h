#pragma once

#include "java.h"
#include "java\method.h"
#include "java\object.h"

namespace java
{
    class method;
    class method_list;
    class object;

    // Wrapper for a Java class object. "clazz" naming is to avoid conflict 
    // with C++ class keyword.
    class clazz
    {
        jclass _class;

    public:
        // This constructor looks up a Java class given it's name.  The 
        // format of the name is 
        // "namespace1/namespace2/..../namespaceN/class_name", e.g., 
        // "java/lang/String".  Generic types don't have any special notation,
        // e.g., java.util.ArrayList<E> is just "java/util/ArrayList".  This 
        // is because the JVM doesn't have any notion of generics- it is only 
        // known at the compiler level.
        clazz(const char* name)
        {
            _class = jvm::find_class(name);
        }

        clazz(jclass cls) : _class(cls) {}

        jclass native() const { return _class; }

        std::string name();

        method lookup_method(const char* name, const std::vector<clazz>& classes);

        method lookup_constructor(const std::vector<clazz>& classes);

        // Returns a list of methods for this class using reflection.
        method_list get_methods();

        // Returns a list of constructors for this class using reflection.
        method_list get_constructors();

        // These methods call static Java methods on the class given the 
        // method name and a number of arguments.  An exception is thrown
        // if an appropriate method is not found.  Also, the first method 
        // which accepts the given arguments is called, even if there is a 
        // "better" match.  For now, if it is necessary to disambiguate, the
        // low-level jvm::call_xxx_method() functions must be used.
        object call_static (const char* method_name);
        object call_static (const char* method_name, object a1);
        object call_static (const char* method_name, object a1, object a2);
        object call_static (const char* method_name, object a1, object a2, object a3);
    };

    // This function can be used to load classes from raw compiled class data 
    // (e.g., content of a .class file generated by javac).  The system class 
    // loader (as returned by java.lang.ClassLoader.getSystemClassLoader()) 
    // is used to load the data into the JVM.
    clazz load_class(const char* class_name, jbyte* class_data, jsize size);
}
